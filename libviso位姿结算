以下内容来自博客MT.Queen:   http://www.cnblogs.com/MT-ComputerVision/p/6339690.html

　　libviso一直以来被称为在视觉里程计(VO)中的老牌开源算法。它通过corner,chessboard两种kernel的响应以及非极大值抑制的方式提取特征，并用sobel算子
与原图卷积的结果作为特征点的描述子。在位姿的计算方面，则通过RANSAC迭代的方式，每次迭代随机抽取3个点，根据这三个点，用高斯牛顿法计算出一个RT矩阵，表示
两帧图像之间，相机的姿态变换。而位姿的计算也是libviso 中较为抽象的一部分，接下来，本文将在读者已经对立体视觉的基本原理，以及libviso的场景流匹配熟悉
的前提下，对这个过程进行详细分析。
    在位姿计算的过程中，输入的是n组通过场景流匹配得到的二维坐标点，每组4个：(u1c,v1c), (u1p,v1p), (u2c,v2c), (u1p,v1p)，分别代表左图、右图，当
前时刻，上一时刻图像中的匹配点（这里用了与代码中相同的符号表示，1下标代表左图，2代表右图，c代表上一阵，p代表当前帧）,(X1c,Y1c,Z1c), (X1p,Y1p,Z1p),
(X2c,Y2c,Z2c), (X1p,Y1p,Z1p)是其对应的三维坐标，根据立体视觉的原理，三维坐标可以通过匹配点坐标结合相机内参数算出。输出是1中描述的6个变量。这6个变
量是通过RANSAC迭代，在每次迭代中都从匹配点中随机抽取3个点，基于这3个点，通过高斯牛顿法的方式求出来的。计算出一次迭代中的参数之后，利用这个参数计算出局
内点(inlier)的占比。最终取占比最高的参数，得到结果。下面将对每次迭代中进行的操作细节进行分析。
